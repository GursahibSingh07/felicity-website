const User = require("../models/User");
const bcrypt = require("bcryptjs");
const generateToken = require("../utils/generateToken");
const { isValidEmail, validatePassword } = require("../utils/emailValidator");
const crypto = require("crypto");
const PasswordResetRequest = require("../models/PasswordResetRequest");

const generatePassword = () => {
  const upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const lower = "abcdefghijklmnopqrstuvwxyz";
  const digits = "0123456789";
  const special = "!@#$%&*";
  let pw = "";
  pw += upper[Math.floor(Math.random() * upper.length)];
  pw += lower[Math.floor(Math.random() * lower.length)];
  pw += digits[Math.floor(Math.random() * digits.length)];
  pw += special[Math.floor(Math.random() * special.length)];
  const all = upper + lower + digits + special;
  for (let i = 0; i < 8; i++) pw += all[Math.floor(Math.random() * all.length)];
  return pw.split("").sort(() => Math.random() - 0.5).join("");
};


const provisionFirstAdmin = async (req, res) => {
  try {
    const adminExists = await User.findOne({ role: "admin" });
    if (adminExists) {
      return res.status(403).json({
        message: "Admin already exists. No additional admins can be provisioned.",
      });
    }

    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({
        message: "Email and password are required",
      });
    }

    if (!isValidEmail(email)) {
      return res.status(400).json({ message: "Invalid email format" });
    }

    const passwordValidation = validatePassword(password);
    if (!passwordValidation.valid) {
      return res.status(400).json({ message: passwordValidation.message });
    }

    const userExists = await User.findOne({ email });
    if (userExists) {
      return res.status(400).json({ message: "User with this email already exists" });
    }

    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    const admin = await User.create({
      email,
      password: hashedPassword,
      role: "admin",
      userType: "admin",
      isRoleLocked: true,
    });

    res.status(201).json({
      message: "First admin provisioned successfully",
      token: generateToken(admin._id),
      user: {
        id: admin._id,
        email: admin.email,
        role: admin.role,
        userType: admin.userType,
      },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};


const createOrganizer = async (req, res) => {
  try {
    const { organizerName, category, description } = req.body;
    let { email, password } = req.body;

    if (!organizerName) {
      return res.status(400).json({ message: "Organizer name is required" });
    }
    if (!category) {
      return res.status(400).json({ message: "Category is required" });
    }
    if (!description) {
      return res.status(400).json({ message: "Description is required" });
    }

    if (!email) {
      const slug = organizerName.toLowerCase().replace(/[^a-z0-9]/g, "");
      email = `${slug}@clubs.event.com`;
      let counter = 1;
      while (await User.findOne({ email })) {
        email = `${slug}${counter}@clubs.event.com`;
        counter++;
      }
    }

    if (!isValidEmail(email)) {
      return res.status(400).json({ message: "Invalid email format" });
    }

    const organizerExists = await User.findOne({ email });
    if (organizerExists) {
      return res.status(400).json({ message: "Organizer with this email already exists" });
    }

    const autoGenerated = !password;
    if (!password) {
      password = generatePassword();
    }

    const passwordValidation = validatePassword(password);
    if (!passwordValidation.valid) {
      return res.status(400).json({ message: passwordValidation.message });
    }

    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    const organizer = await User.create({
      email,
      password: hashedPassword,
      role: "organizer",
      userType: "organizer",
      isRoleLocked: true,
      createdBy: req.user.id,
      organizerName,
      category,
      description,
    });

    res.status(201).json({
      message: "Organizer account created successfully",
      credentials: {
        email: organizer.email,
        password: password,
        autoGenerated,
      },
      user: {
        id: organizer._id,
        email: organizer.email,
        role: organizer.role,
        userType: organizer.userType,
        organizerName: organizer.organizerName,
        category: organizer.category,
        description: organizer.description,
        createdAt: organizer.createdAt,
      },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};


const resetOrganizerPassword = async (req, res) => {
  try {
    const { organizerId, newPassword } = req.body;

    if (!organizerId || !newPassword) {
      return res.status(400).json({
        message: "organizerId and newPassword are required",
      });
    }

    const passwordValidation = validatePassword(newPassword);
    if (!passwordValidation.valid) {
      return res.status(400).json({ message: passwordValidation.message });
    }

    const organizer = await User.findById(organizerId);
    if (!organizer || organizer.role !== "organizer") {
      return res.status(404).json({
        message: "Organizer not found",
      });
    }

    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(newPassword, salt);

    organizer.password = hashedPassword;
    await organizer.save();

    res.json({
      message: "Organizer password reset successfully",
      organizer: {
        id: organizer._id,
        email: organizer.email,
      },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};


const getAllOrganizers = async (req, res) => {
  try {
    const organizers = await User.find({ role: "organizer" }).select("-password");
    const Event = require("../models/Event");
    const results = [];
    for (const org of organizers) {
      const eventCount = await Event.countDocuments({ createdBy: org._id });
      results.push({ ...org.toObject(), eventCount });
    }
    res.json({ message: "Organizers retrieved successfully", count: results.length, organizers: results });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

const toggleOrganizerStatus = async (req, res) => {
  try {
    const { organizerId } = req.params;
    const organizer = await User.findById(organizerId);
    if (!organizer || organizer.role !== "organizer") {
      return res.status(404).json({ message: "Organizer not found" });
    }
    organizer.isDisabled = !organizer.isDisabled;
    await organizer.save();
    res.json({
      message: `Organizer ${organizer.isDisabled ? "disabled" : "enabled"} successfully`,
      organizer: { id: organizer._id, email: organizer.email, isDisabled: organizer.isDisabled },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};


const deleteOrganizer = async (req, res) => {
  try {
    const { organizerId } = req.params;

    const organizer = await User.findById(organizerId);
    if (!organizer || organizer.role !== "organizer") {
      return res.status(404).json({
        message: "Organizer not found",
      });
    }

    await User.deleteOne({ _id: organizerId });

    res.json({
      message: "Organizer deleted successfully",
      organizer: {
        id: organizerId,
        email: organizer.email,
      },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

const requestPasswordReset = async (req, res) => {
  try {
    const { reason } = req.body;
    if (!reason || !reason.trim()) {
      return res.status(400).json({ message: "Reason is required" });
    }

    const existing = await PasswordResetRequest.findOne({
      organizer: req.user.id,
      status: "pending",
    });
    if (existing) {
      return res.status(400).json({ message: "You already have a pending reset request" });
    }

    const request = await PasswordResetRequest.create({
      organizer: req.user.id,
      reason: reason.trim(),
    });

    res.status(201).json({
      message: "Password reset request submitted",
      request: { id: request._id, status: request.status, createdAt: request.createdAt },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

const getMyResetRequests = async (req, res) => {
  try {
    const requests = await PasswordResetRequest.find({ organizer: req.user.id })
      .sort({ createdAt: -1 });

    res.status(200).json(requests);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

const getAllResetRequests = async (req, res) => {
  try {
    const requests = await PasswordResetRequest.find()
      .populate("organizer", "email organizerName category")
      .populate("processedBy", "email")
      .sort({ createdAt: -1 });

    res.status(200).json(requests);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

const approveResetRequest = async (req, res) => {
  try {
    const request = await PasswordResetRequest.findById(req.params.requestId).populate("organizer");
    if (!request) return res.status(404).json({ message: "Request not found" });
    if (request.status !== "pending") {
      return res.status(400).json({ message: `Request is already ${request.status}` });
    }

    const newPassword = generatePassword();
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(newPassword, salt);

    request.organizer.password = hashedPassword;
    await request.organizer.save();

    request.status = "approved";
    request.adminComment = req.body.comment || "";
    request.processedBy = req.user.id;
    request.processedAt = new Date();
    request.generatedPassword = newPassword;
    await request.save();

    res.status(200).json({
      message: "Password reset approved",
      credentials: {
        email: request.organizer.email,
        organizerName: request.organizer.organizerName,
        newPassword,
      },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

const rejectResetRequest = async (req, res) => {
  try {
    const request = await PasswordResetRequest.findById(req.params.requestId);
    if (!request) return res.status(404).json({ message: "Request not found" });
    if (request.status !== "pending") {
      return res.status(400).json({ message: `Request is already ${request.status}` });
    }

    request.status = "rejected";
    request.adminComment = req.body.comment || "Request rejected";
    request.processedBy = req.user.id;
    request.processedAt = new Date();
    await request.save();

    res.status(200).json({ message: "Password reset request rejected" });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

module.exports = {
  provisionFirstAdmin,
  createOrganizer,
  resetOrganizerPassword,
  getAllOrganizers,
  deleteOrganizer,
  toggleOrganizerStatus,
  requestPasswordReset,
  getMyResetRequests,
  getAllResetRequests,
  approveResetRequest,
  rejectResetRequest,
};
